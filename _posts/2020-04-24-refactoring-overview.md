---
layout: post
title: "重构-概述"
description: "The first 'Hello world' post for Simple Texture theme."
category: ['软件工程']
tags: ["重构", "编码"]
---

对于一个事物, 照旧是灵魂三问:
1. 是什么?
1. 为什么?
1. 怎么做?


### 什么是重构?

书中给出了两个定义, 一个名词, 一个动词

> 重构(名词) : 对软件结构的一种调整, 目的是在不改变软件的可观察行为的前提下, 提高其可理解性, 降低其修改成本.

> 重构(动词) : 使用一系列重构手法, 在不改变软件可观察行为的前提下, 调整其结构.

两个定义都提到了一个至关重要的词**不改变可观察行为**, 直截了当的说就是用户一端不应该感知到你的修改, 不论这个用户是另一个程序员还是商业上的用户. 

另外一个重要的词是**结构**, 重构调整的代码的结构. 就是简单的把函数从文件A移动到文件B. 虽然说这些操作看起来不起眼, 并且有一点瞎搞的意思. 但是经过大量的软件工程师的实践, 重构确实能够保持代码的活力.


### 为什么重构?
重构的最大的目的就是保持代码的活力. 业界对于很久之前遗留下来的运行中的代码有一个称呼---**屎山**, 这些代码往往是十年之前的, 由于时间的关系, 某一领域的编码手段会有很大的变化, 因此去理解一份远古时代的代码是很困难的.

重构的的目的有以下几个:
1. 改进软件的设计
    在开发中架构是很容易腐败的. 设计可能不合时宜, 并且在不断的功能扩展中大几率会不合适.
    而重构能够让架构有调整的机会, 不断的保持架构是最合适的状态.

1. 让代码更容易理解
    一方面模块的划分, 让阅读代码的时候不必记下一大堆的环境.

    重构给函数和变量起一个最合适的名字也是极为有利于代码理解的.

1. 帮助找到bug
    重构都是极小的修改, 哪里引入的bug很容易发现
1. 提高编程速度
    提高了发现bug的速度和减少了扩展新功能的时间来加速编码.(曲线救国)

### 什么时候重构?
在确定什么时候需要重构之前, 我们先确定什么时候不重构.
并不是所有的代码都需要重构.
当一段"需要重构"的代码被隐藏在一个API之下的时候, 并且不需要理解这一个API. 那么就不需要重构.
当重写比重构还简单的时候, 那就直接重写.

下面介绍重构的时机.
1. 当需要添加新功能的时候
    重构能够让添加新功能更容易, 但是如果已经很容易了就不要重构了.
1. 需要理解代码的时候
    重构来帮助自己理解代码, 重构让代码的可读性更高, 这就会帮助理解代码.
1. 发现有更好的做法
    有时候阅读代码的时候能够发现一些不好的代码. 对这些代码进行重构.
    如果重构的工作量很小那么就直接重构, 如果需要一段时间, 那么就先记下来, 完成目前的任务再回来重构.
1. 代码审查的时候
    代码审查的时候和上一个时机差不多.

### 构造重构体系
使用CI, 单元测试来构造重构体系.

使用CI让每一点修改都能够提交到代码库进行同步, 让大家看到的都是最新的代码.

使用单元测试来保持代码的可观察行为不变.

### 代码的坏味道.
如果你发现了代码的坏味道, 那么就重构他.(但是先考虑这一段代码是否需要重构)

1. 神秘命名
    无法解释用途的名称都是不好的名称.
1. 重复代码
    重复代码的问题与数据库冗余的问题一样, 会造成修改的不一致.
1. 过长函数
    初次见到大量短函数代码库的程序员会觉得程序里到处都是委托调用.

    小函数也会给代码的阅读者带来负担, 需要切换上下文.

    太长的函数的问题在于代码不够灵活, 复用性较低.

    分解函数的原则是:**每当感觉需要注释来说明一些什么的时候, 就把要说明的放进一个独立的函数中, 并以用途命名.** 尽可能在代码中显示"做什么", 较少的暴露"怎么做", 更加有利于阅读.

    **就算只有一行代码, 如果需要注释来说明, 那也值得提取到独立函数中**

1. 过长函数参数列表
    太长的参数列表令人迷惑.

    对于相关联的几个参数使用类将其包装起来.

1. 全局数据
    全局数据的问题依旧是全局的可修改性,

    全局数据包括全局变量, 类静态变量和单例.

    处理全局数据的最佳方式是控制其作用域, 禁止任意的修改.
1. 可变数据
    可变数据的存在在多线程编程中是一个令人头痛的问题. 
    对可变数据的处理依旧是进行约束, 禁止其任意的变化.

1. 发散式变化
    发散式变化是项目腐败的最大杀手, 当你添加一个功能需要修改三个函数, 而调整这三个函数又要涉及到另外的十个函数, 这十个函数又会涉及到几十个函数的时候. 心智负担过大. 很难修改.

    处理办法最好是分离函数, 形成单独的上下文.
1. 霰弹式修改
    有些类似于发散式变化. 每当遇到某种变化, 需要修改若干个类, 所面临的就是霰弹式修改.
    这一问题的处理方法就是把分散的逻辑整合到一起.

1. 依恋情结
    一个函数和另一个模块的交互格外频繁, 远超过自己模块内部.

    处理办法就是将和依赖其他模块的部分移动到其他模块.

1. 数据泥团
    成组出现的数据.
    建议使用类来包装起来.

1. 基本类型偏执
    很多时候不愿意创建领域类型, 而使用基本类型替代表示. 典型的就是字符串.

    自定义类型的最大好处是能够增加约束. 例如不同的长度单位.

1. 重复的switch
    重复的switch问题也在于修改一致性上.
    当庞大的代码库中出现了好几个相同的switch, 修改但凡漏掉一个就会引发bug.
    使用多态来替代.

1. 循环语句
    使用管道取代循环. 实现函数式编程.

1. 冗余的元素
    只有一个函数的类.
    将其内联

1. 无用的通用性
    许多时候都会因为过度设计写出来一些暂时没有用途的通用类.
    如果一个函数或者类的唯一用户是测试用例. 那么就移除掉测试和代码本身.

1. 临时字段
    一些只为特殊情况存在的字段. 后来者很难猜测其用途.
1. 过长的消息链
    冗长的对象调用关系.  意味着客户端代码和调用关系紧密耦合.
    建议使用隐藏委托关系来处理.

1. 中间人
    A对B的调用委托给C, 变成A调用C, C调用B. 过度使用则会隐藏起来实际关系. 某个类的接口有一大半的函数都是委托给其他类, 这就是过度运用.

1. 内幕交易
    两个模块之间隐藏的大量的数据交流.

    处理手段主要是函数的移动, 新模块的创建.

1. 过大的类
    单个类完成了太多的任务, 将其分成几个小的职责单一的类.


1. 异曲同工的类
    两个类完成一件事, 可以用于实现的替换.

1. 纯数据类
    只有数据和访问器的类, 没有行为.

    纯数据类意味着行为被放在了错误的地方.

    例外情况就是纯数据类的对象被用作函数调用的返回结果.

1. 被拒绝的馈赠
    子类会继承超类中的函数和数据, 如果子类并不需要所有继承来的东西. 

    如果子类拒绝支持超类的接口, 那么就不应该继承.

1. 注释
    如果需要一段注释来解释代码, 那么将代码替换为函数, 用函数名来解释. 


    如果续呀注释说明系统的规格需求, 那么使用断言.

